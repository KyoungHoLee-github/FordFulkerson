# 네트워크 유량
FordFulkerson 알고리즘은 최대 유량 알고리즘의 한 종류이다.  
최대 유량 알고리즘은 유량 네트워크를 이용하여 최대 유량 문제를 푸는 알고리즘이다  
- 유량 네트워크 : 각각의 간선이 용량을 갖는 방향성 그래프
- 최대 유량 문제 : 유량 네트워크에서 주어진 두 정점 사이의 최대 유량을 찾는 문제
  
최대 유량 문제는 각 경로로 보낼 수 있는 초당 최대 용량은 경로에 포함된 간선 중 가장 용량이 작은 간선에 의해 결정된다.  
ex) [s, a, t] = min(15, 25, 5) = 5 -> s에서 t로 보낼 수 있는 초당 최대 유량은 5가 됨  
  
최대 유량 문제는 결국 `출발지(source)`에서 `도착지(sink)`까지 흘려보낼 수 있는 최대 `유량(flow)`을 구하는 문제이다.  
- `출발지(source)` : 유량이 시작되는 정점(S)
- `도착지(sink)` : 유량잉 도착하는 정점(T)
- `유량(flow)` : 두 정점 사이에서 흐르는 양
- `용량(capacity)` : 두 정점 사이에 최대로 흐를 수 있는 양
- `잔여 용량(residual capacity)` : 두 정점 사이에서 현제 더 흐를 수 있는 용량 (`capacity` - `flow`)
- `증가 경로(augmenting path)` : S에서 T로 흐르는 유량의 경로
  
유량 네트워크의 속성
- `c(u,v)` : 정점 u에서 v로 가는 간선의 용량(capacity)
- `f(u,v)` : 정점 u에서 v로 실제 흐르는 유량(flow)
- `r(u,v)` : 정점 u에서 v로 가는 잔여 용량 `r(u,v)` = `c(u,v)` - `f(u,v)`
- 용량 제한 속성 : `f(u,v)` <= `c(u,v)`
- 유량의 대칭성 : `f(u,v)` = `-f(v,u)`
- 유량의 보존 : 각 정점에 들어오는 유량과 나가는 유량은 같음
  
최대유량 알고리즘을 구현할 때 실행결과를 확인하기 위해 국내 알고리즘 사이트 '백준'에서 최대유량 알고리즘 문제를 찾아봤다.  

# FordFulkerson
FordFulkerson 알고리즘은 최대 유량을 찾아내는 알고리즘으로 DFS(깊이 우선탐색)를 이용하기 때문에 최단경로는 아니다.  
  
### 동작방법   
1. 각 간선의 용량을 입력받는다.
2. DFS를 이용하여 `r(u,v)` > 0인 증가 경로를 찾는다.
3. 찾은 증가경로에서 `r(u,v)`이 가장 낮은 간선을 찾는다.
4. 찾은 간선의 `r(u,v)`만큼만 S에서 T까지 유량을 보낸다.
5. 증가 경로가 더 이상 발견되지 않을 때까지 1-4과정을 반복한다.
  
아래 그래프를 살펴보면  
![](https://user-images.githubusercontent.com/101320758/165692128-1416946a-0e9f-4b74-81af-8cc4c142db6e.png)
S->3의 용량은 2, 유량은 0으로 잔여용량이 있으므로 해당 간선을 따라간다.  
3->2의 용량은 1, 유량은 0으로 잔여용량이 있으므로 해당 간선을 따라간다.  
2->T의 용량은 3, 유량은 0으로 잔여용량이 있으므로 해당 간선을 따라간다.  
S->T로 가는 증가 경로를 찾아냈으므로 이 경로에 유량을 흘려주는데, 흘려 줄 수 있는 유량은 해당 증가경로의 간선들의 잔여 용량 중 최솟값이므로 S->3->2->T의 잔여용량이 가장 작은 3->2 경로의 잔여용량 1만큼 흘려주게 된다.  
그러면 아래와 같이 된다.  
![](https://user-images.githubusercontent.com/101320758/165692216-d5527972-f913-4d7d-b434-35e0aaa95a2a.png)
다시 S부터 시작하여 증가경로를 찾는다.  
S->3의 용량은 2, 유량은 1로 잔여용량이 1남아있으므로 해당 간선을 따라간다.  
3->2의 잔여용량이 남아있지 않으므로 다른 간선을 탐색한다.  
3->T의 용량은 2, 유량은 1로 잔여용량이 1남아있으므로 해당 간선을 따라간다.  
S->3->T증가경로를 찾아 냈으므로 잔여용량중 최솟값인 1만큼 유량을 흘려주고  
이후에 S에서 증가경로를 한번 더 찾으면 S->2, 2->T로 이루어진 S->2->T의 증가경로를 찾을 수 있고 최소 잔여용량 2만큼을 흘려주게 된다.  
그러면 아래와 같이 된다.  
![](https://user-images.githubusercontent.com/101320758/165692234-dd0a6b91-ad05-471f-8a83-76a7a0efdc65.png)
위 그림을 보면 더 이상의 증가경로가 없는것으로 보이지만 위 유량 네트워크 속성에서 유량의 대칭성을 통해 역방향 간선들의 유량을 모두 표시하면 아래와 같은 그림이 된다.  
![](https://user-images.githubusercontent.com/101320758/165692753-f115d5ba-3bba-42fb-b794-3f4ce0552c4d.jpg)
이제 위 그림을 보면 S->2에 잔여용량이 1 남아있으므로 해당 간선을 따라간다.  
그러고 2->3의 역방향 간선을 보면 용량이 0이고 유량이 -1이므로 잔여용량이 1 남아있기 때문에 해당 간선을 따라간다.  
3->T로 잔여 용량이 1 남아있으므로 S->2->3->T의 증가 경로를 찾았고 이 증가경로의 잔여용량 최솟값 1을 흘려주면 최대 유량이 5라는 것을 찾을 수 있다.  
### 시간 복잡도  
