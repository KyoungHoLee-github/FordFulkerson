# 네트워크 유량
FordFulkerson 알고리즘은 최대 유량 알고리즘의 한 종류이다.  
최대 유량 알고리즘은 유량 네트워크를 이용하여 최대 유량 문제를 푸는 알고리즘이다  
- 유량 네트워크 : 각각의 간선이 용량을 갖는 방향성 그래프
- 최대 유량 문제 : 유량 네트워크에서 주어진 두 정점 사이의 최대 유량을 찾는 문제
  
최대 유량 문제는 각 경로로 보낼 수 있는 초당 최대 용량은 경로에 포함된 간선 중 가장 용량이 작은 간선에 의해 결정된다.  
ex) [s, a, t] = min(15, 25, 5) = 5 -> s에서 t로 보낼 수 있는 초당 최대 유량은 5가 됨  
  
최대 유량 문제는 결국 `출발지(source)`에서 `도착지(sink)`까지 흘려보낼 수 있는 최대 `유량(flow)`을 구하는 문제이다.  
- `출발지(source)` : 유량이 시작되는 정점(S)
- `도착지(sink)` : 유량잉 도착하는 정점(T)
- `유량(flow)` : 두 정점 사이에서 흐르는 양
- `용량(capacity)` : 두 정점 사이에 최대로 흐를 수 있는 양
- `잔여 용량(residual capacity)` : 두 정점 사이에서 현제 더 흐를 수 있는 용량 (`capacity` - `flow`)
- `증가 경로(augmenting path)` : S에서 T로 흐르는 유량의 경로
  
유량 네트워크의 속성
- `c(u,v)` : 정점 u에서 v로 가는 간선의 용량(capacity)
- `f(u,v)` : 정점 u에서 v로 실제 흐르는 유량(flow)
- `r(u,v)` : 정점 u에서 v로 가는 잔여 용량 `r(u,v)` = `c(u,v)` - `f(u,v)`
- 용량 제한 속성 : `f(u,v)` <= `c(u,v)`
- 유량의 대칭성 : `f(u,v)` = `-f(v,u)`
- 유량의 보존 : 각 정점에 들어오는 유량과 나가는 유량은 같음
  
최대유량 알고리즘을 구현할 때 실행결과를 확인하기 위해 국내 알고리즘 사이트 '백준'에서 최대유량 알고리즘 문제를 찾아봤다.  

# FordFulkerson
FordFulkerson 알고리즘은 최대 유량을 찾아내는 알고리즘으로 DFS(깊이 우선탐색)를 이용하기 때문에 최단경로는 아니다.  
  
### 동작방법   
1. 각 간선의 용량을 입력받는다.
2. DFS를 이용하여 `r(u,v)` > 0인 증가 경로를 찾는다.
3. 찾은 증가경로에서 `r(u,v)`이 가장 낮은 간선을 찾는다.
4. 찾은 간선의 `r(u,v)`만큼만 S에서 T까지 유량을 보낸다.
5. 증가 경로가 더 이상 발견되지 않을 때까지 1-4과정을 반복한다.
  
아래 그래프를 살펴보면  
![](https://user-images.githubusercontent.com/101320758/165692128-1416946a-0e9f-4b74-81af-8cc4c142db6e.png)  
S->3의 용량은 2, 유량은 0으로 잔여용량이 있으므로 해당 간선을 따라간다.  
3->2의 용량은 1, 유량은 0으로 잔여용량이 있으므로 해당 간선을 따라간다.  
2->T의 용량은 3, 유량은 0으로 잔여용량이 있으므로 해당 간선을 따라간다.  
S->T로 가는 증가 경로를 찾아냈으므로 이 경로에 유량을 흘려주는데, 흘려 줄 수 있는 유량은 해당 증가경로의 간선들의 잔여 용량 중 최솟값이므로 S->3->2->T의 잔여용량이 가장 작은 3->2 경로의 잔여용량 1만큼 흘려주게 된다.  
그러면 아래와 같이 된다.  
![](https://user-images.githubusercontent.com/101320758/165692216-d5527972-f913-4d7d-b434-35e0aaa95a2a.png)  
다시 S부터 시작하여 증가경로를 찾는다.  
S->3의 용량은 2, 유량은 1로 잔여용량이 1남아있으므로 해당 간선을 따라간다.  
3->2의 잔여용량이 남아있지 않으므로 다른 간선을 탐색한다.  
3->T의 용량은 2, 유량은 1로 잔여용량이 1남아있으므로 해당 간선을 따라간다.  
S->3->T증가경로를 찾아 냈으므로 잔여용량중 최솟값인 1만큼 유량을 흘려주고  
이후에 S에서 증가경로를 한번 더 찾으면 S->2, 2->T로 이루어진 S->2->T의 증가경로를 찾을 수 있고 최소 잔여용량 2만큼을 흘려주게 된다.  
그러면 아래와 같이 된다.  
![](https://user-images.githubusercontent.com/101320758/165692234-dd0a6b91-ad05-471f-8a83-76a7a0efdc65.png)  
위 그림을 보면 더 이상의 증가경로가 없는것으로 보이지만 위 유량 네트워크 속성에서 유량의 대칭성을 통해 역방향 간선들의 유량을 모두 표시하면 아래와 같은 그림이 된다.  
![](https://user-images.githubusercontent.com/101320758/165692753-f115d5ba-3bba-42fb-b794-3f4ce0552c4d.jpg)  
이제 위 그림을 보면 S->2에 잔여용량이 1 남아있으므로 해당 간선을 따라간다.  
그러고 2->3의 역방향 간선을 보면 용량이 0이고 유량이 -1이므로 잔여용량이 1 남아있기 때문에 해당 간선을 따라간다.  
3->T로 잔여 용량이 1 남아있으므로 S->2->3->T의 증가 경로를 찾았고 이 증가경로의 잔여용량 최솟값 1을 흘려주면 최대 유량이 5라는 것을 찾을 수 있다.  
### 시간 복잡도  
시간복잡도는 `O((V+E)F)`인데, E>V로 지배적이기 때문에 보통 `O(EF)`라고 표현한다.  

### 실행결과  
![](https://user-images.githubusercontent.com/101320758/165711078-145344fe-7506-473d-b5fc-1711ec6ac26c.png) 
![](https://user-images.githubusercontent.com/101320758/165722909-94ee6a33-fea0-46f7-acdf-4fa5b2d3da2f.png)  
  
# EdmondsKarp  
최대 유량 알고리즘에 대해 공부하던 도중 탐색방법에 따라 FordFulkerson 알고리즘, EdmondsKarp 알고리즘으로 분류된다.  
FordFulkerson 알고리즘이 DFS방식으로 증가경로를 탐색했다면, EdmonsKarp 알고리즘은 BFS방식으로 증가경로를 탐색한다.  
BFS방식으로 탐색하기 때문에 가장 짧은 경로의 증가 경로를 탐색하여 증가경로에 보낼 수 있는 최대 유량을 한번에 보내면 되는 알고리즘이다.  
즉, EdmondsKarp 알고리즘은 최단경로로 최대의 유량을 보내기 때문에 위에 FordFulkerson알고리즘으로 보였던 중간에 잇는 용량이 1인 엣지가 껴있더라도 최단경로가 아니라면 무시할 수 있다.  
  
### 동작방법  
1. 각 간선의 용량을 입력받는다.
2. BFS를 이용하여 `r(u,v)` > 0인 증가 경로 중 최단 거리를 찾는다.
3. 찾은 증가경로에서 `r(u,v)`이 가장 낮은 간선을 찾는다.
4. 찾은 간선의 `r(u,v)`만큼만 S에서 T까지 유량을 보낸다.
5. 증가 경로가 더 이상 발견되지 않을 때까지 1-4과정을 반복한다.

### 시간복잡도  
이 알고리즘의시간복잡도는`min(O(EF),O(VE^2))`이다.  
즉, 아무리 유량이 커도 유량이 아닌 정점 개수와 간선 개수의 제곱에 비례한다는 의미이다.  
만약 어떤 잔여 그래프에서 증가 경로를 찾는데 그 중에서 최단경로만 찾는다하고, 길이가 d인 어떤 최단 경로에 유량을 흘려주면 그 경로에 있는 간선중 하나는 무조건 포화 간산이 된다.  
이때, 이 간선이 다시 참조되는 일은 최단거리의 길이가 d인 한 절대로 일어나지 않는다.  
이 간선을 다시 참조하려면 역방향 간선으로 유량을 흘려주어 이 간선이 다시 비포화 상태가 되어야 하는데 찾은 경로가 d와 같거나 더 짧은 일은 절대 일어나지 않는다.  
따라서 d가 증가하여야만 다시 이 간선을 참조하게된다. 최단 경로를 고정했을 때 `O(E)`개의 경로만을 찾게 되고, 최단 경로의 길이는 길어봐야 V로 최대 V개의 길이를 가지게 되므로 최대 `O(VE^2)`가 소요된다.  

### 실행결과  
![](https://user-images.githubusercontent.com/101320758/165711198-a038a79a-feb5-49a6-81a0-4a72e49aa27c.png) 
![](https://user-images.githubusercontent.com/101320758/165722926-65e0180a-b018-4221-a64f-082bf8f2dbc6.png)  
  
## Review  
이번에 `FordFulkerson` 알고리즘에대해 공부하면서 유량이 흐르는데 어떻게 흐르고 동작하는데 이해하는 것이 처음에는 쉽지않았다. 그래도 공부하다가 한번 동작방식에 대해 이해하고나니 탐색방법만 다른 `EdmondsKarp` 알고리즘을 이해하는데 어렵지 않았다.  
그러나 이 내용들을 코딩을 해보는데 탐색하는 부분에서 재귀함수를 계속 호출하여 탐색하는 부분에서 어려움을 느꼈다.  
최대 유량 알고리즘을 구현하면서 각각 `DFS`, `BFS`로 탐색하는 방법이 다른 알고리즘 `ForddFulkerson`, `EdmonsKarp` 알고리즘을 구현했는데 소로 시간복잡도가 다른 것도 있어 실행시간을 비교해보았다.  
실행시간을 비교하는데 있어 `currentTimeMillis`메소드를 사용하여 구현해보았는데 메인함수 처음부분에 적다보니 `BufferReader`클래스로 입력받는 부분도 실행시간에 포함되어 어려음을 겪었다. 결국에 해결방안을 완벽히 찾지 못하고 입력된 값을 하나 읽어오고난 이후 시간을 비교하는것을 대체하였다.  
그러나 이 방법도 실행 할 때마다 실행시간의 오차범위가 꽤 있는 편이였고 왜 그런지에 대해 공부해보니 `currentTimeMillis`는 다른 작업의 영향을 받거나 시스템의 시간을 변경하는 경우 등 측정 결과에 영향을 줄 수 잇는 요소들이 있기 때문에 성능측정을 위한 코드의 수행 시간을 기록하기에는 적합하지 않을 수 있다는 사실을 알 수 있었다.  
지금은 현재 `currentTimeeMillis`메소드를 그대로 사용하였지만 나중에 조사하면서 알게 된 `nanoTime`도 적용해보았는데 이 또한 입력부분도 시간에 포함되는 어려움이 있고 실행시마다 오차범위가 꽤 있는 편이였다.  
실행시간을 표현하기 위해 위의 과정들을 거쳤지만 실행시간의 오차범위도 크다보니 `FordFulkerson`알고리즘이 `EdmondsKarp` 알고리즘보다 빠를 때도 있고 느릴 때도 있어 실행시간 결과로 확인하기에는 무리가 있다곡 생각이 들었다. 그러나 실행시간에 대한 메소드들이 어떤게 있는지 또, 어떤 메소드가 어떤 단점이 있는지 등을 배울 수 있었다.
